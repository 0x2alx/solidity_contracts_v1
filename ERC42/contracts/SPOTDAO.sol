// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

/***
 *
 *      sSSs   .S_sSSs      sSSs_sSSs    sdSS_SSSSSSbs  S.       .S    sSSSSs   .S    S.   sdSS_SSSSSSbs
 *     d%%SP  .SS~YS%%b    d%%SP~YS%%b   YSSS~S%SSSSSP  SS.     .SS   d%%%%SP  .SS    SS.  YSSS~S%SSSSSP
 *    d%S'    S%S   `S%b  d%S'     `S%b       S%S       S%S     S%S  d%S'      S%S    S%S       S%S
 *    S%|     S%S    S%S  S%S       S%S       S%S       S%S     S%S  S%S       S%S    S%S       S%S
 *    S&S     S%S    d*S  S&S       S&S       S&S       S&S     S&S  S&S       S%S SSSS%S       S&S
 *    Y&Ss    S&S   .S*S  S&S       S&S       S&S       S&S     S&S  S&S       S&S  SSS&S       S&S
 *    `S&&S   S&S_sdSSS   S&S       S&S       S&S       S&S     S&S  S&S       S&S    S&S       S&S
 *      `S*S  S&S~YSSY    S&S       S&S       S&S       S&S     S&S  S&S sSSs  S&S    S&S       S&S
 *       l*S  S*S         S*b       d*S       S*S       S*b     S*S  S*b `S%%  S*S    S*S       S*S
 *      .S*P  S*S         S*S.     .S*S       S*S       S*S.    S*S  S*S   S%  S*S    S*S       S*S
 *    sSS*S   S*S          SSSbs_sdSSS        S*S        SSSbs  S*S   SS_sSSS  S*S    S*S       S*S
 *    YSS'    S*S           YSSP~YSSY         S*S         YSSP  S*S    Y~YSSY  SSS    S*S       S*S
 *            SP                              SP                SP                    SP        SP
 *            Y                               Y                 Y                     Y         Y
 *
 *     .S_sSSs     .S_SSSs      sSSs_sSSs
 *    .SS~YS%%b   .SS~SSSSS    d%%SP~YS%%b
 *    S%S   `S%b  S%S   SSSS  d%S'     `S%b
 *    S%S    S%S  S%S    S%S  S%S       S%S
 *    S%S    S&S  S%S SSSS%S  S&S       S&S
 *    S&S    S&S  S&S  SSS%S  S&S       S&S
 *    S&S    S&S  S&S    S&S  S&S       S&S
 *    S&S    S&S  S&S    S&S  S&S       S&S
 *    S*S    d*S  S*S    S&S  S*b       d*S
 *    S*S   .S*S  S*S    S*S  S*S.     .S*S
 *    S*S_sdSSS   S*S    S*S   SSSbs_sdSSS
 *    SSS~YSSY    SSS    S*S    YSSP~YSSY
 *                       SP
 *                       Y
 *
 *
 *
 * FOUNDER: Nathan (@awildfig) from @avril15NFT
 * DEV: @ghooost0x2a
 **********************************
 * @title: Spotlight DAO
 * @author: @ghooost0x2a ⊂(´･◡･⊂ )∘˚˳°
 **********************************
 * ERC1155 with marketplace (approval) blacklisting, Soul Bound Tokens, OpenSea royalties compliant
 *****************************************************************
 *      .-----.
 *    .' -   - '.
 *   /  .-. .-.  \
 *   |  | | | |  |
 *    \ \o/ \o/ /
 *   _/    ^    \_
 *  | \  '---'  / |
 *  / /`--. .--`\ \
 * / /'---` `---'\ \
 * '.__.       .__.'
 *     `|     |`
 *      |     \
 *      \      '--.
 *       '.        `\
 *         `'---.   |
 *            ,__) /
 *             `..'
 */

import "./ERC1155G.sol";
import "./ERC1155PausableG.sol";
import "./RevokableDefaultOperatorFilterer.sol";
import "./UpdatableOperatorFilterer.sol";
import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract SPOTLIGHTDAO is
    ERC1155G,
    Ownable,
    AccessControlEnumerable,
    ERC1155PausableG,
    RevokableDefaultOperatorFilterer
{
    using Strings for uint256;
    string public constant name = "SPOTLIGHTDAO";
    string public constant symbol = "SPOTDAO";
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    string internal baseURI;
    string internal uriSuffix;
    string internal contract_URI;
    bool internal use_new_uri_notation;
    mapping(uint256 => bool) public tokensOpenToPublic;
    mapping(uint256 => bool) public isSoulBoundToken;
    uint256 public PUBLIC_MINT_PRICE = 0.01 ether;
    bool public PUBLIC_MINT_OPEN = false;
    address public paymentRecipient = address(0);

    address internal MASTER_SIGNER;
    mapping(uint256 => bytes32) internal processedNonces; // This is for (optionally) tracking of used master signatures (to avoid transaction replaying)
    mapping(uint256 => bytes32) internal processedNoncesBurn; // This is for (optionally) tracking of used master signatures (to avoid transaction replaying)

    struct Master_Approval {
        address addy; // Address authorized to mint
        uint256 price; // Price per token
        uint256 valid_until_timestamp; // Unix timestamp of the master sig
        uint256 id; // Token ID authorized for mint
        uint256 max_per_wallet; // Token ID authorized for mint
        uint256 qty; // Amount authorized to mint
        uint256 sig_nonce; // Generated by master when signing - If different than 0, track and enforce unique signatures
    }
    struct Master_Approval_Burn {
        address addy;
        uint256 valid_until_timestamp;
        uint256 token_id_to_mint;
        uint256 token_id_to_burn;
        uint256 nb_tokens_to_burn;
        uint256 nb_tokens_to_mint;
        uint256 is_locked_for_mint;
        uint256 sig_nonce;
    }

    struct EIP712Domain {
        string name;
        string version;
        uint256 chainId;
        address verifyingContract;
    }

    bytes32 constant EIP712DOMAIN_TYPEHASH =
        keccak256(
            "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
        );
    bytes32 constant MA_TYPEHASH =
        keccak256(
            "Master_Approval(address addy,uint256 price,uint256 valid_until_timestamp,uint256 id,uint256 max_per_wallet,uint256 qty,uint256 sig_nonce)"
        );
    bytes32 constant MAB_TYPEHASH =
        keccak256(
            "Master_Approval_Burn(address addy,uint256 valid_until_timestamp,uint256 token_id_to_mint,uint256 token_id_to_burn,uint256 nb_tokens_to_burn,uint256 nb_tokens_to_mint,uint256 is_locked_for_mint,uint256 sig_nonce)"
        );
    bytes32 DOMAIN_SEPARATOR;

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE`, and `PAUSER_ROLE` to the account that
     * deploys the contract.
     */
    constructor() ERC1155G("overwritten URI") Ownable() {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(PAUSER_ROLE, _msgSender());
        _setupRole(
            DEFAULT_ADMIN_ROLE,
            0xA94F799A34887582987eC8C050f080e252B70A21
        );
        _setupRole(MINTER_ROLE, 0xA94F799A34887582987eC8C050f080e252B70A21);
        _setupRole(PAUSER_ROLE, 0xA94F799A34887582987eC8C050f080e252B70A21);
        _setDefaultRoyalty(0xA94F799A34887582987eC8C050f080e252B70A21, 700);
        isSoulBoundToken[1] = true;
        tokensOpenToPublic[2] = true;
        DOMAIN_SEPARATOR = hash(
            EIP712Domain({
                name: "SPOTLIGHTDAO",
                version: "1",
                //chainId: block.chainId,
                chainId: 1,
                // verifyingContract: this
                verifyingContract: address(this)
            })
        );
    }

    fallback() external payable {}

    receive() external payable {}

    function hash(
        EIP712Domain memory eip712Domain
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    EIP712DOMAIN_TYPEHASH,
                    keccak256(bytes(eip712Domain.name)),
                    keccak256(bytes(eip712Domain.version)),
                    eip712Domain.chainId,
                    eip712Domain.verifyingContract
                )
            );
    }

    // Function to hash the Master Approval struct
    function hash(
        Master_Approval calldata m_a
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    MA_TYPEHASH,
                    m_a.addy,
                    m_a.price,
                    m_a.valid_until_timestamp,
                    m_a.id,
                    m_a.max_per_wallet,
                    m_a.qty,
                    m_a.sig_nonce
                )
            );
    }

    // Function to hash the Master Approval struct
    function hash(
        Master_Approval_Burn calldata m_ab
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    MAB_TYPEHASH,
                    m_ab.addy,
                    m_ab.valid_until_timestamp,
                    m_ab.token_id_to_mint,
                    m_ab.token_id_to_burn,
                    m_ab.nb_tokens_to_burn,
                    m_ab.nb_tokens_to_mint,
                    m_ab.is_locked_for_mint,
                    m_ab.sig_nonce
                )
            );
    }

    function get_master_signer()
        external
        view
        onlyRole(DEFAULT_ADMIN_ROLE)
        returns (address master_signer)
    {
        return MASTER_SIGNER;
    }

    function get_signer(
        Master_Approval calldata m_a,
        bytes memory _master_signature
    ) public view returns (address) {
        bytes32 digest = keccak256(
            abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, hash(m_a))
        );
        (bytes32 r, bytes32 s, uint8 v) = split_signature(_master_signature);
        return ecrecover(digest, v, r, s);
    }

    function get_signer_b(
        Master_Approval_Burn calldata m_ab,
        bytes memory _master_signature
    ) public view returns (address) {
        bytes32 digest = keccak256(
            abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, hash(m_ab))
        );
        (bytes32 r, bytes32 s, uint8 v) = split_signature(_master_signature);
        return ecrecover(digest, v, r, s);
    }

    function split_signature(
        bytes memory sig
    ) public pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(sig.length == 65, "invalid signature length");

        assembly {
            /*
                First 32 bytes stores the length of the signature

                add(sig, 32) = pointer of sig + 32
                effectively, skips first 32 bytes of signature

                mload(p) loads next 32 bytes starting at the memory address p into memory
                */

            // first 32 bytes, after the length prefix
            r := mload(add(sig, 32))
            // second 32 bytes
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes)
            v := byte(0, mload(add(sig, 96)))
        }

        // implicitly return (r, s, v)
    }

    function lock_token(uint256 _tokenid) public onlyRole(DEFAULT_ADMIN_ROLE) {
        _set_locked_supply_tokens(_tokenid, true);
    }

    function setSoulBoundToken(
        uint256 token_id,
        bool _is_soul_bound
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        isSoulBoundToken[token_id] = _is_soul_bound;
    }

    function setMasterSigConf(
        address _master_signer
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        MASTER_SIGNER = _master_signer;
    }

    function setDefaultRoyalty(
        address receiver,
        uint96 feeNumerator
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _setDefaultRoyalty(receiver, feeNumerator);
    }

    function deleteDefaultRoyalty() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _deleteDefaultRoyalty();
    }

    function contractURI() public view returns (string memory) {
        return contract_URI;
    }

    function setTokenRoyalty(
        uint256 tokenId,
        address receiver,
        uint96 feeNumerator
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _setTokenRoyalty(tokenId, receiver, feeNumerator);
    }

    function resetTokenRoyalty(
        uint256 tokenId
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _resetTokenRoyalty(tokenId);
    }

    function setPaymentRecipient(
        address addy
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        paymentRecipient = addy;
    }

    function setBaseSuffixURI(
        string calldata newBaseURI,
        string calldata newURISuffix,
        string calldata newContractURI
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        baseURI = newBaseURI;
        uriSuffix = newURISuffix;
        contract_URI = newContractURI;
    }

    function configurePublicMint(
        uint256 mint_price,
        bool is_open
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        PUBLIC_MINT_OPEN = is_open;
        PUBLIC_MINT_PRICE = mint_price;
    }

    function authorizeTokenForPublic(
        uint256 tokenId
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        tokensOpenToPublic[tokenId] = true;
    }

    function useNewUriStd(bool use_new) external onlyRole(DEFAULT_ADMIN_ROLE) {
        use_new_uri_notation = use_new;
    }

    function updateBlackListedApprovals(
        address[] calldata addys,
        bool[] calldata blacklisted
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        require(
            addys.length == blacklisted.length,
            "Nb addys doesn't match nb bools."
        );
        for (uint256 i; i < addys.length; ++i) {
            _updateBlackListedApprovals(addys[i], blacklisted[i]);
        }
    }

    function uri(
        uint256 tokenId
    ) public view virtual override returns (string memory) {
        if (use_new_uri_notation) {
            return
                bytes(baseURI).length > 0
                    ? string(abi.encodePacked(baseURI, "{id}", uriSuffix))
                    : "";
        }

        return
            bytes(baseURI).length > 0
                ? string(
                    abi.encodePacked(baseURI, tokenId.toString(), uriSuffix)
                )
                : "";
    }

    /**
     * @dev Creates `amount` new tokens for `to`, of token type `id`.
     *
     * See {ERC1155-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function adminMint(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public {
        require(hasRole(MINTER_ROLE, _msgSender()), "Mint restricted");
        _mint(to, id, amount, data);
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] variant of {mint}.
     */
    function adminMintBatch(
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public {
        require(hasRole(MINTER_ROLE, _msgSender()), "Mint restricted");
        _mintBatch(to, ids, amounts, data);
    }

    function masterBurn(
        address account,
        uint256 id,
        uint256 value
    ) public onlyRole(DEFAULT_ADMIN_ROLE) {
        require(
            isSoulBoundToken[id],
            "Only soul bound tokens can be master burned"
        );

        _burn(account, id, value);
    }

    function publicMint(uint256 qty, uint256 id) public payable {
        require(PUBLIC_MINT_OPEN, "Public mint not open");
        require(tokensOpenToPublic[id], "Token not open to public mint.");
        require(
            qty * PUBLIC_MINT_PRICE == msg.value,
            "Wront amount of ETH sent"
        );
        _mint(_msgSender(), id, qty, "");
    }

    function masterSigMint(
        Master_Approval calldata m_a,
        bytes memory _master_sig
    ) external payable {
        require(
            get_signer(m_a, _master_sig) == MASTER_SIGNER,
            "Invalid master sig!"
        );
        require(m_a.addy == _msgSender(), "Not approved minter!");

        require(
            msg.value >= m_a.price * m_a.qty,
            "Invalid amount of ETH sent!"
        );
        if (m_a.max_per_wallet != 0) {
            require(
                m_a.qty + balanceOf(_msgSender(), m_a.id) <= m_a.max_per_wallet,
                "Too many per wallet!"
            );
        }
        if (block.timestamp < m_a.valid_until_timestamp) {
            bytes32 msig = keccak256(_master_sig);
            if (m_a.sig_nonce != 0) {
                require(
                    processedNonces[m_a.sig_nonce] != msig,
                    "Sig already used!"
                );
                processedNonces[m_a.sig_nonce] = msig;
            }
        } else {
            revert("Signature Expired!");
        }
        _mint(_msgSender(), m_a.id, m_a.qty, "");
    }

    function masterSigBurnToClaim(
        Master_Approval_Burn calldata m_ab,
        bytes memory _master_sig
    ) external {
        require(
            get_signer_b(m_ab, _master_sig) == MASTER_SIGNER,
            "Invalid master sig!"
        );
        require(m_ab.addy == _msgSender(), "Not approved minter!");
        if (block.timestamp < m_ab.valid_until_timestamp) {
            bytes32 msig = keccak256(_master_sig);
            if (m_ab.sig_nonce != 0) {
                require(
                    processedNoncesBurn[m_ab.sig_nonce] != msig,
                    "Sig already used!"
                );
                processedNoncesBurn[m_ab.sig_nonce] = msig;
            }
        } else {
            revert("Signature Expired!");
        }
        require(
            balanceOf(_msgSender(), m_ab.token_id_to_burn) >=
                m_ab.nb_tokens_to_burn,
            "Not enough tokens to burn!"
        );
        _burn(_msgSender(), m_ab.token_id_to_burn, m_ab.nb_tokens_to_burn);
        _mint(_msgSender(), m_ab.token_id_to_mint, m_ab.nb_tokens_to_mint, "");
        if (m_ab.is_locked_for_mint == 42) {
            _set_locked_supply_tokens(m_ab.token_id_to_mint, true);
        }
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC1155Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function pause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), "Unauthorized");
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC1155Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - the caller must have the `PAUSER_ROLE`.
     */
    function unpause() public virtual {
        require(hasRole(PAUSER_ROLE, _msgSender()), "Unauthorized");
        _unpause();
    }

    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual override(ERC1155G, ERC1155PausableG) {
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
        if (from != address(0) && to != address(0)) {
            for (uint256 ind = 0; ind < ids.length; ind++) {
                require(!isSoulBoundToken[ids[ind]], "Soul Bound token!");
            }
        }
    }

    function setApprovalForAll(
        address operator,
        bool approved
    ) public override onlyAllowedOperatorApproval(operator) {
        super.setApprovalForAll(operator, approved);
    }

    /**
     * @dev See {IERC1155-safeTransferFrom}.
     *      In this example the added modifier ensures that the operator is allowed by the OperatorFilterRegistry.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        uint256 amount,
        bytes memory data
    ) public override onlyAllowedOperator(from) {
        super.safeTransferFrom(from, to, tokenId, amount, data);
    }

    /**
     * @dev See {IERC1155-safeBatchTransferFrom}.
     *      In this example the added modifier ensures that the operator is allowed by the OperatorFilterRegistry.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override onlyAllowedOperator(from) {
        super.safeBatchTransferFrom(from, to, ids, amounts, data);
    }

    function owner()
        public
        view
        virtual
        override(Ownable, UpdatableOperatorFilterer)
        returns (address)
    {
        return Ownable.owner();
    }

    function supportsInterface(
        bytes4 interfaceId
    )
        public
        view
        virtual
        override(ERC1155G, AccessControlEnumerable)
        returns (bool)
    {
        return
            interfaceId == type(IAccessControlEnumerable).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    //Just in case some ETH ends up in the contract so it doesn't remain stuck.
    function withdraw() external {
        uint256 contract_balance = address(this).balance;

        require(
            paymentRecipient != address(0),
            "Don't withdraw to null address"
        );
        address payable w_addy = payable(paymentRecipient);

        (bool success, ) = w_addy.call{value: (contract_balance)}("");
        require(success, "Withdrawal failed!");
    }
}
