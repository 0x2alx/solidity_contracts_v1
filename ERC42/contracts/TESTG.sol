// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

contract TESTG {
    struct Struct_test {
        uint256 var1; // Price per token
        uint256 var2; // Unix timestamp of the master sig
        uint256 var3; // Token ID authorized for mint
        uint256 var4; // Token ID authorized for mint
        uint256 var5; // Amount authorized to mint
        uint256 var6; // Generated by master when signing - If different than 0, track and enforce unique signatures
    }
    struct EIP712Domain {
        string name;
        string version;
        uint256 chainId;
        address verifyingContract;
    }
    bytes32 constant EIP712DOMAIN_TYPEHASH =
        keccak256(
            "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
        );
    bytes32 constant Struct_test_TH =
        keccak256(
            "Struct_test(uint256 var1,uint256 var2,uint256 var3,uint256 var4,uint256 var5,uint256 var6)"
        );
    bytes32 DOMAIN_SEPARATOR;
    address internal MASTER_SIGNER;
    mapping(uint256 => uint256) internal nonces1;

    constructor() {
        DOMAIN_SEPARATOR = hash(
            EIP712Domain({
                name: "TESTG",
                version: "1",
                //chainId: block.chainId,
                chainId: 1,
                // verifyingContract: this
                verifyingContract: address(this)
            })
        );
    }

    function hash(
        EIP712Domain memory eip712Domain
    ) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    EIP712DOMAIN_TYPEHASH,
                    keccak256(bytes(eip712Domain.name)),
                    keccak256(bytes(eip712Domain.version)),
                    eip712Domain.chainId,
                    eip712Domain.verifyingContract
                )
            );
    }

    // Function to hash the Master Approval struct
    function hash(Struct_test calldata m_a) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    Struct_test_TH,
                    m_a.var1,
                    m_a.var2,
                    m_a.var3,
                    m_a.var4,
                    m_a.var5,
                    m_a.var6
                )
            );
    }

    function get_master_signer() external view returns (address master_signer) {
        return MASTER_SIGNER;
    }

    function get_signer(
        Struct_test calldata m_ab,
        bytes memory _master_signature
    ) public view returns (address) {
        bytes32 digest = keccak256(
            abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, hash(m_ab))
        );
        (bytes32 r, bytes32 s, uint8 v) = split_signature(_master_signature);
        return ecrecover(digest, v, r, s);
    }

    function split_signature(
        bytes memory sig
    ) public pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(sig.length == 65, "invalid signature length");

        assembly {
            /*
                First 32 bytes stores the length of the signature

                add(sig, 32) = pointer of sig + 32
                effectively, skips first 32 bytes of signature

                mload(p) loads next 32 bytes starting at the memory address p into memory
                */

            // first 32 bytes, after the length prefix
            r := mload(add(sig, 32))
            // second 32 bytes
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes)
            v := byte(0, mload(add(sig, 96)))
        }

        // implicitly return (r, s, v)
    }

    function setMasterSigConf(address _master_signer) external {
        MASTER_SIGNER = _master_signer;
    }

    function testInitMapping(
        Struct_test calldata m_a,
        bytes memory _master_sig
    ) external payable {
        require(
            get_signer(m_a, _master_sig) == MASTER_SIGNER,
            "Invalid master sig!"
        );
        for (uint256 i = 0; i < 7; i++) {
            nonces1[i] = block.timestamp + block.number;
        }
    }

    function testUpdateMapping(
        Struct_test calldata m_a,
        bytes memory _master_sig
    ) external payable {
        require(
            get_signer(m_a, _master_sig) == MASTER_SIGNER,
            "Invalid master sig!"
        );
        for (uint256 i = 0; i < 7; i++) {
            nonces1[i] = block.timestamp + block.number;
        }
    }
}
